import numpy
from typing import Callable, ClassVar, overload

A1_TAI_OFFSET: float
ARCSEC_DEG: float
ARCSEC_RAD: float
AU: float
C: float
CARTESIAN: OrbitStateRepres
CLASSICAL_OE: OrbitStateRepres
DAYS_CENTURY: float
DAYS_SEC: float
DAYS_WEEK: float
DAYS_YEAR: float
DEG: float
DEG_ARCSEC: float
DEIMOS: NaifId
DELAUNAY_OE: OrbitStateRepres
D_EARTH_EMB: float
D_EARTH_MOON: float
D_MOON_EMB: float
E: float
EARTH: NaifId
EARTH_MOON_BARYCENTER: NaifId
ECEF: Frame
ECI: Frame
EMB: NaifId
EME: Frame
EMR: Frame
EPS: float
EQUINOTICAL_OE: OrbitStateRepres
FOOT_M: float
GCRF: Frame
GM_CERES: float
GM_EARTH: float
GM_JUPITER_SYSTEM: float
GM_MARS_SYSTEM: float
GM_MERCURY: float
GM_MOON: float
GM_NEPTUNE_SYSTEM: float
GM_PLUTO_SYSTEM: float
GM_SATURN_SYSTEM: float
GM_SUN: float
GM_URANUS_SYSTEM: float
GM_VENUS: float
GM_VESTA: float
GPS: Time
GSE: Frame
HOURS_DAY: float
ICRF: Frame
INCH_M: float
ITRF: Frame
JD_J2000: float
JD_JAN_5_1941: float
JD_MJD_OFFSET: float
JD_NOV_17_1858: float
JD_T0: float
JD_TDB: Time
JD_TT: Time
JULIAN_DATE_OF_010541: int
JUPITER: NaifId
JUPITER_BARYCENTER: NaifId
KM_M: float
LBM_TO_KG: float
L_B: float
L_G: float
MARS: NaifId
MARS_BARYCENTER: NaifId
MARS_FIXED: Frame
MERCURY: NaifId
MERCURY_BARYCENTER: NaifId
MILE_M: float
MINS_DAY: float
MINS_HOUR: float
MJD_J2000: float
MOD: Frame
MOON: NaifId
MOON_CI: Frame
MOON_ME: Frame
MOON_OP: Frame
MOON_PA: Frame
M_KM: float
NEPTUNE_BARYCENTER: NaifId
NUM_SECS: float
OMEGA_EARTH_MOON: float
PHOBOS: NaifId
PI: float
PI_OVER_TWO: float
PLUTO_BARYCENTER: NaifId
QUASINONSINGULAR_ROE: OrbitStateRepres
QUASI_NONSINGULAR_OE: OrbitStateRepres
RAD: float
RAD_ARCSEC: float
RK4: IntegratorType
RK8: IntegratorType
RKF45: IntegratorType
R_EARTH: float
R_MOON: float
SATURN_BARYCENTER: NaifId
SECS_DAY: float
SECS_HOUR: float
SECS_MINUTE: float
SER: Frame
SINGULAR_ROE: OrbitStateRepres
SLUG_TO_KG: float
SOLAR_SYSTEM_BARYCENTER: NaifId
SSB: NaifId
SUN: NaifId
TAI: Time
TCB: Time
TCG: Time
TDB: Time
TIME_OF_J2000: float
TOD: Frame
TT: Time
TT_TAI_OFFSET: float
TWO_PI: float
URANUS_BARYCENTER: NaifId
UT1: Time
UTC: Time
VENUS: NaifId
VENUS_BARYCENTER: NaifId
VENUS_FIXED: Frame

class Animal:
    def __init__(self) -> None: ...
    def go(self, arg0: int) -> str: ...
    def name(self) -> str: ...

class Body:
    def __init__(self) -> None: ...
    @staticmethod
    def Earth(n: int = ..., m: int = ..., gravity_file: str = ...) -> Body: ...
    @staticmethod
    def Mars(n: int = ..., m: int = ..., gravity_file: str = ...) -> Body: ...
    @staticmethod
    def Moon(n: int = ..., m: int = ..., gravity_file: str = ...) -> Body: ...
    @staticmethod
    def Sun() -> Body: ...
    @staticmethod
    def Venus(n: int = ..., m: int = ..., gravity_file: str = ...) -> Body: ...
    @property
    def GM(self) -> float: ...
    @property
    def R(self) -> float: ...
    @property
    def fixed_frame(self) -> Frame: ...
    @property
    def gravity_field(self): ...
    @property
    def id(self) -> NaifId: ...
    @property
    def inertial_frame(self) -> Frame: ...
    @property
    def name(self) -> str: ...
    @property
    def use_gravity_field(self) -> bool: ...

class CartesianOrbitState(OrbitState):
    r: numpy.ndarray[numpy.float64[3, 1]]
    v: numpy.ndarray[numpy.float64[3, 1]]
    def __init__(self, rv: numpy.ndarray[numpy.float64[6, 1]], frame: Frame = ...) -> None: ...

class CartesianTwoBodyDynamics(NumericalOrbitDynamics):
    def __init__(self, GM: float, integ_type: IntegratorType = ...) -> None: ...
    def compute_rates(self, t: float, x: numpy.ndarray[numpy.float64[6, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]: ...
    @overload
    def propagate(self, x0: numpy.ndarray[numpy.float64[6, 1]], t0: float, tf: float, stm: bool = ...) -> object: ...
    @overload
    def propagate(self, x0: numpy.ndarray[numpy.float64[1, 6]], t0: float, tf: float, stm: bool = ...) -> object: ...
    @overload
    def propagate(self, x0: numpy.ndarray[numpy.float64[m, 6]], t0: float, tf: float) -> numpy.ndarray[numpy.float64[m, 6]]: ...
    @overload
    def propagate(self, x0: numpy.ndarray[numpy.float64[6, 1]], t0: float, tf: numpy.ndarray[numpy.float64[m, 1]], progress: bool = ...) -> numpy.ndarray[numpy.float64[m, 6]]: ...
    @overload
    def propagate(self, x0: numpy.ndarray[numpy.float64[1, 6]], t0: float, tf: numpy.ndarray[numpy.float64[m, 1]], progress: bool = ...) -> numpy.ndarray[numpy.float64[m, 6]]: ...
    def propagate_state(self, state: OrbitState, t0: float, tf: float, stm: bool = ...) -> object: ...

class ClassicalOE(OrbitState):
    M: float
    Omega: float
    a: float
    e: float
    i: float
    w: float
    def __init__(self, [a,e,i,Omega,w,M]: numpy.ndarray[numpy.float64[6, 1]], frame: Frame = ...) -> None: ...

class Dog(Animal):
    def __init__(self) -> None: ...
    def bark(self) -> str: ...

class EquinoctialOE(OrbitState):
    a: float
    h: float
    k: float
    lon: float
    p: float
    q: float
    def __init__(self, rv: numpy.ndarray[numpy.float64[6, 1]], frame: Frame = ...) -> None: ...

class Frame:
    __members__: ClassVar[dict] = ...  # read-only
    ECEF: ClassVar[Frame] = ...
    ECI: ClassVar[Frame] = ...
    EME: ClassVar[Frame] = ...
    EMR: ClassVar[Frame] = ...
    GCRF: ClassVar[Frame] = ...
    GSE: ClassVar[Frame] = ...
    ICRF: ClassVar[Frame] = ...
    ITRF: ClassVar[Frame] = ...
    MARS_FIXED: ClassVar[Frame] = ...
    MOD: ClassVar[Frame] = ...
    MOON_CI: ClassVar[Frame] = ...
    MOON_ME: ClassVar[Frame] = ...
    MOON_OP: ClassVar[Frame] = ...
    MOON_PA: ClassVar[Frame] = ...
    SER: ClassVar[Frame] = ...
    TOD: ClassVar[Frame] = ...
    VENUS_FIXED: ClassVar[Frame] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GravityField:
    def __init__(self) -> None: ...
    @property
    def CS(self) -> numpy.ndarray[numpy.float64[m, n]]: ...
    @property
    def GM(self) -> float: ...
    @property
    def R(self) -> float: ...
    @property
    def m(self) -> int: ...
    @property
    def m_max(self) -> int: ...
    @property
    def n(self) -> int: ...
    @property
    def n_max(self) -> int: ...

class Husky(Dog):
    def __init__(self) -> None: ...

class IAnalyticalOrbitDynamics(IOrbitDynamics):
    def __init__(self, *args, **kwargs) -> None: ...

class IDynamics:
    def __init__(self, *args, **kwargs) -> None: ...

class IOrbitDynamics(IDynamics):
    def __init__(self, *args, **kwargs) -> None: ...

class IntegratorType:
    __members__: ClassVar[dict] = ...  # read-only
    RK4: ClassVar[IntegratorType] = ...
    RK8: ClassVar[IntegratorType] = ...
    RKF45: ClassVar[IntegratorType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class J2CartTwoBodyDynamics(NumericalOrbitDynamics):
    def __init__(self, GM: float, J2: float, R_body: float, integ_type: IntegratorType = ...) -> None: ...
    def compute_rates(self, t: float, x: numpy.ndarray[numpy.float64[6, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]: ...
    @overload
    def propagate(self, x0: numpy.ndarray[numpy.float64[6, 1]], t0: float, tf: float, stm: bool = ...) -> object: ...
    @overload
    def propagate(self, x0: numpy.ndarray[numpy.float64[1, 6]], t0: float, tf: float, stm: bool = ...) -> object: ...
    @overload
    def propagate(self, x0: numpy.ndarray[numpy.float64[m, 6]], t0: float, tf: float) -> numpy.ndarray[numpy.float64[m, 6]]: ...
    @overload
    def propagate(self, x0: numpy.ndarray[numpy.float64[6, 1]], t0: float, tf: numpy.ndarray[numpy.float64[m, 1]], progress: bool = ...) -> numpy.ndarray[numpy.float64[m, 6]]: ...
    @overload
    def propagate(self, x0: numpy.ndarray[numpy.float64[1, 6]], t0: float, tf: numpy.ndarray[numpy.float64[m, 1]], progress: bool = ...) -> numpy.ndarray[numpy.float64[m, 6]]: ...
    def propagate_state(self, state: OrbitState, t0: float, tf: float, stm: bool = ...) -> object: ...

class J2KeplerianDynamics(NumericalOrbitDynamics):
    def __init__(self, GM: float, J2: float, R_body: float, integ_type: IntegratorType = ...) -> None: ...
    def compute_rates(self, t: float, x: numpy.ndarray[numpy.float64[6, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]: ...
    @overload
    def propagate(self, x0: numpy.ndarray[numpy.float64[6, 1]], t0: float, tf: float, stm: bool = ...) -> object: ...
    @overload
    def propagate(self, x0: numpy.ndarray[numpy.float64[1, 6]], t0: float, tf: float, stm: bool = ...) -> object: ...
    @overload
    def propagate(self, x0: numpy.ndarray[numpy.float64[m, 6]], t0: float, tf: float) -> numpy.ndarray[numpy.float64[m, 6]]: ...
    @overload
    def propagate(self, x0: numpy.ndarray[numpy.float64[6, 1]], t0: float, tf: numpy.ndarray[numpy.float64[m, 1]], progress: bool = ...) -> numpy.ndarray[numpy.float64[m, 6]]: ...
    @overload
    def propagate(self, x0: numpy.ndarray[numpy.float64[1, 6]], t0: float, tf: numpy.ndarray[numpy.float64[m, 1]], progress: bool = ...) -> numpy.ndarray[numpy.float64[m, 6]]: ...
    def propagate_state(self, state: OrbitState, t0: float, tf: float, stm: bool = ...) -> object: ...

class KeplerianDynamics(IAnalyticalOrbitDynamics):
    def __init__(self, GM: float) -> None: ...
    @overload
    def propagate(self, x0: numpy.ndarray[numpy.float64[6, 1]], t0: float, tf: float, stm: bool = ...) -> object: ...
    @overload
    def propagate(self, x0: numpy.ndarray[numpy.float64[1, 6]], t0: float, tf: float, stm: bool = ...) -> object: ...
    @overload
    def propagate(self, x0: numpy.ndarray[numpy.float64[m, 6]], t0: float, tf: float) -> numpy.ndarray[numpy.float64[m, 6]]: ...
    @overload
    def propagate(self, x0: numpy.ndarray[numpy.float64[6, 1]], t0: float, tf: numpy.ndarray[numpy.float64[m, 1]], progress: bool = ...) -> numpy.ndarray[numpy.float64[m, 6]]: ...
    @overload
    def propagate(self, x0: numpy.ndarray[numpy.float64[1, 6]], t0: float, tf: numpy.ndarray[numpy.float64[m, 1]], progress: bool = ...) -> numpy.ndarray[numpy.float64[m, 6]]: ...
    def propagate_state(self, state: OrbitState, t0: float, tf: float, stm: bool = ...) -> object: ...

class NBodyDynamics(NumericalOrbitDynamics):
    def __init__(self, integ_type: IntegratorType = ...) -> None: ...
    def add_body(self, body) -> None: ...
    def get_bodies(self, *args, **kwargs): ...
    @overload
    def propagate(self, x0: numpy.ndarray[numpy.float64[6, 1]], t0: float, tf: float, stm: bool = ...) -> object: ...
    @overload
    def propagate(self, x0: numpy.ndarray[numpy.float64[1, 6]], t0: float, tf: float, stm: bool = ...) -> object: ...
    @overload
    def propagate(self, x0: numpy.ndarray[numpy.float64[m, 6]], t0: float, tf: float) -> numpy.ndarray[numpy.float64[m, 6]]: ...
    @overload
    def propagate(self, x0: numpy.ndarray[numpy.float64[6, 1]], t0: float, tf: numpy.ndarray[numpy.float64[m, 1]], progress: bool = ...) -> numpy.ndarray[numpy.float64[m, 6]]: ...
    @overload
    def propagate(self, x0: numpy.ndarray[numpy.float64[1, 6]], t0: float, tf: numpy.ndarray[numpy.float64[m, 1]], progress: bool = ...) -> numpy.ndarray[numpy.float64[m, 6]]: ...
    def propagate_state(self, state: OrbitState, t0: float, tf: float, stm: bool = ...) -> object: ...
    def set_frame(self, frame: Frame) -> None: ...

class NaifId:
    __members__: ClassVar[dict] = ...  # read-only
    DEIMOS: ClassVar[NaifId] = ...
    EARTH: ClassVar[NaifId] = ...
    EARTH_MOON_BARYCENTER: ClassVar[NaifId] = ...
    EMB: ClassVar[NaifId] = ...
    JUPITER: ClassVar[NaifId] = ...
    JUPITER_BARYCENTER: ClassVar[NaifId] = ...
    MARS: ClassVar[NaifId] = ...
    MARS_BARYCENTER: ClassVar[NaifId] = ...
    MERCURY: ClassVar[NaifId] = ...
    MERCURY_BARYCENTER: ClassVar[NaifId] = ...
    MOON: ClassVar[NaifId] = ...
    NEPTUNE_BARYCENTER: ClassVar[NaifId] = ...
    PHOBOS: ClassVar[NaifId] = ...
    PLUTO_BARYCENTER: ClassVar[NaifId] = ...
    SATURN_BARYCENTER: ClassVar[NaifId] = ...
    SOLAR_SYSTEM_BARYCENTER: ClassVar[NaifId] = ...
    SSB: ClassVar[NaifId] = ...
    SUN: ClassVar[NaifId] = ...
    URANUS_BARYCENTER: ClassVar[NaifId] = ...
    VENUS: ClassVar[NaifId] = ...
    VENUS_BARYCENTER: ClassVar[NaifId] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class NumericalOrbitDynamics(IOrbitDynamics):
    def __init__(self, *args, **kwargs) -> None: ...
    def get_time_step(self) -> float: ...
    def set_ode_function(self, arg0: Callable[[float, numpy.ndarray[numpy.float64[m, 1]]], numpy.ndarray[numpy.float64[m, 1]]]) -> None: ...
    def set_time_step(self, arg0: float) -> None: ...

class OrbitState:
    frame: Frame
    state_repres: OrbitStateRepres
    vector: numpy.ndarray[numpy.float64[6, 1]]
    def __init__(self, vector: numpy.ndarray[numpy.float64[6, 1]], frame: Frame, state_repres: OrbitStateRepres, names, units) -> None: ...
    @property
    def names(self): ...
    @property
    def size(self) -> int: ...
    @property
    def units(self): ...

class OrbitStateRepres:
    __members__: ClassVar[dict] = ...  # read-only
    CARTESIAN: ClassVar[OrbitStateRepres] = ...
    CLASSICAL_OE: ClassVar[OrbitStateRepres] = ...
    DELAUNAY_OE: ClassVar[OrbitStateRepres] = ...
    EQUINOTICAL_OE: ClassVar[OrbitStateRepres] = ...
    QUASINONSINGULAR_ROE: ClassVar[OrbitStateRepres] = ...
    QUASI_NONSINGULAR_OE: ClassVar[OrbitStateRepres] = ...
    SINGULAR_ROE: ClassVar[OrbitStateRepres] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class QuasiNonsingOE(OrbitState):
    Omega: float
    a: float
    ex: float
    ey: float
    i: float
    u: float
    def __init__(self, rv: numpy.ndarray[numpy.float64[6, 1]], frame: Frame = ...) -> None: ...

class QuasiNonsingROE(OrbitState):
    ada: float
    adex: float
    adey: float
    adix: float
    adiy: float
    adl: float
    def __init__(self, arg0: numpy.ndarray[numpy.float64[6, 1]], arg1: Frame) -> None: ...

class SingularROE(OrbitState):
    adM: float
    adOmega: float
    ada: float
    ade: float
    adi: float
    adw: float
    def __init__(self, arg0: numpy.ndarray[numpy.float64[6, 1]], arg1: Frame) -> None: ...

class Time:
    __members__: ClassVar[dict] = ...  # read-only
    GPS: ClassVar[Time] = ...
    JD_TDB: ClassVar[Time] = ...
    JD_TT: ClassVar[Time] = ...
    TAI: ClassVar[Time] = ...
    TCB: ClassVar[Time] = ...
    TCG: ClassVar[Time] = ...
    TDB: ClassVar[Time] = ...
    TT: ClassVar[Time] = ...
    UT1: ClassVar[Time] = ...
    UTC: ClassVar[Time] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

def acceleration_gravity_field(r: numpy.ndarray[numpy.float64[3, 1]], GM: float, R: float, CS: numpy.ndarray[numpy.float64[m, n]], n_max: int, m_max: int) -> numpy.ndarray[numpy.float64[3, 1]]: ...
def acceleration_point_mass(r: numpy.ndarray[numpy.float64[3, 1]], s: numpy.ndarray[numpy.float64[3, 1]], GM: float) -> numpy.ndarray[numpy.float64[3, 1]]: ...
def acceleration_solar_radiation(r: numpy.ndarray[numpy.float64[3, 1]], r_sun: numpy.ndarray[numpy.float64[3, 1]], area: float, mass: float, CR: float, P_SUN: float, AU: float) -> numpy.ndarray[numpy.float64[3, 1]]: ...
@overload
def az_el_range2cart(aer: numpy.ndarray[numpy.float64[3, 1]], xyz_ref: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]: ...
@overload
def az_el_range2cart(aer: numpy.ndarray[numpy.float64[1, 3]], xyz_ref: numpy.ndarray[numpy.float64[1, 3]]) -> numpy.ndarray[numpy.float64[1, 3]]: ...
@overload
def az_el_range2cart(aer: numpy.ndarray[numpy.float64[m, 3]], xyz_ref: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[m, 3]]: ...
@overload
def az_el_range2cart(aer: numpy.ndarray[numpy.float64[3, 1]], xyz_ref: numpy.ndarray[numpy.float64[m, 3]]) -> numpy.ndarray[numpy.float64[m, 3]]: ...
@overload
def az_el_range2cart(aer: numpy.ndarray[numpy.float64[m, 3]], xyz_ref: numpy.ndarray[numpy.float64[m, 3]]) -> numpy.ndarray[numpy.float64[m, 3]]: ...
@overload
def cart2az_el_range(xzy: numpy.ndarray[numpy.float64[3, 1]], xyz_ref: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]: ...
@overload
def cart2az_el_range(xzy: numpy.ndarray[numpy.float64[1, 3]], xyz_ref: numpy.ndarray[numpy.float64[1, 3]]) -> numpy.ndarray[numpy.float64[1, 3]]: ...
@overload
def cart2az_el_range(xzy: numpy.ndarray[numpy.float64[m, 3]], xyz_ref: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[m, 3]]: ...
@overload
def cart2az_el_range(xzy: numpy.ndarray[numpy.float64[3, 1]], xyz_ref: numpy.ndarray[numpy.float64[m, 3]]) -> numpy.ndarray[numpy.float64[m, 3]]: ...
@overload
def cart2az_el_range(xzy: numpy.ndarray[numpy.float64[m, 3]], xyz_ref: numpy.ndarray[numpy.float64[m, 3]]) -> numpy.ndarray[numpy.float64[m, 3]]: ...
@overload
def cart2classical(cart: CartesianOrbitState, GM: float) -> ClassicalOE: ...
@overload
def cart2classical(cart: numpy.ndarray[numpy.float64[6, 1]], GM: float) -> numpy.ndarray[numpy.float64[6, 1]]: ...
@overload
def cart2classical(cart: numpy.ndarray[numpy.float64[6, 1]], GM: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def cart2classical(cart: numpy.ndarray[numpy.float64[m, 6]], GM: float) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def cart2classical(cart: numpy.ndarray[numpy.float64[m, 6]], GM: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def cart2east_north_up(xzy: numpy.ndarray[numpy.float64[3, 1]], xyz_ref: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]: ...
@overload
def cart2east_north_up(xzy: numpy.ndarray[numpy.float64[1, 3]], xyz_ref: numpy.ndarray[numpy.float64[1, 3]]) -> numpy.ndarray[numpy.float64[1, 3]]: ...
@overload
def cart2east_north_up(xzy: numpy.ndarray[numpy.float64[m, 3]], xyz_ref: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[m, 3]]: ...
@overload
def cart2east_north_up(xzy: numpy.ndarray[numpy.float64[3, 1]], xyz_ref: numpy.ndarray[numpy.float64[m, 3]]) -> numpy.ndarray[numpy.float64[m, 3]]: ...
@overload
def cart2east_north_up(xzy: numpy.ndarray[numpy.float64[m, 3]], xyz_ref: numpy.ndarray[numpy.float64[m, 3]]) -> numpy.ndarray[numpy.float64[m, 3]]: ...
@overload
def cart2lat_lon_alt(r_cart: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]: ...
@overload
def cart2lat_lon_alt(r_cart: numpy.ndarray[numpy.float64[m, 3]]) -> numpy.ndarray[numpy.float64[m, 3]]: ...
@overload
def cart2lat_lon_alt(r_cart: numpy.ndarray[numpy.float64[3, 1]], R_body: float) -> numpy.ndarray[numpy.float64[3, 1]]: ...
@overload
def cart2lat_lon_alt(r_cart: numpy.ndarray[numpy.float64[3, 1]], R_body: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 3]]: ...
@overload
def cart2lat_lon_alt(r_cart: numpy.ndarray[numpy.float64[m, 3]], R_body: float) -> numpy.ndarray[numpy.float64[m, 3]]: ...
@overload
def cart2lat_lon_alt(r_cart: numpy.ndarray[numpy.float64[m, 3]], R_body: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 3]]: ...
@overload
def classical2cart(coe: ClassicalOE, GM: float) -> CartesianOrbitState: ...
@overload
def classical2cart(coe: numpy.ndarray[numpy.float64[6, 1]], GM: float) -> numpy.ndarray[numpy.float64[6, 1]]: ...
@overload
def classical2cart(coe: numpy.ndarray[numpy.float64[6, 1]], GM: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def classical2cart(coe: numpy.ndarray[numpy.float64[m, 6]], GM: float) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def classical2cart(coe: numpy.ndarray[numpy.float64[m, 6]], GM: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def classical2delaunay(coe: numpy.ndarray[numpy.float64[6, 1]], GM: float) -> numpy.ndarray[numpy.float64[6, 1]]: ...
@overload
def classical2delaunay(coe: numpy.ndarray[numpy.float64[6, 1]], GM: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def classical2delaunay(coe: numpy.ndarray[numpy.float64[m, 6]], GM: float) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def classical2delaunay(coe: numpy.ndarray[numpy.float64[m, 6]], GM: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def classical2equinoctial(arg0: ClassicalOE, arg1: float) -> EquinoctialOE: ...
@overload
def classical2equinoctial(coe: numpy.ndarray[numpy.float64[6, 1]], GM: float) -> numpy.ndarray[numpy.float64[6, 1]]: ...
@overload
def classical2equinoctial(coe: numpy.ndarray[numpy.float64[6, 1]], GM: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def classical2equinoctial(coe: numpy.ndarray[numpy.float64[m, 6]], GM: float) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def classical2equinoctial(coe: numpy.ndarray[numpy.float64[m, 6]], GM: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def classical2quasi_nonsingular(coe: ClassicalOE, GM: float) -> QuasiNonsingOE: ...
@overload
def classical2quasi_nonsingular(coe: numpy.ndarray[numpy.float64[6, 1]], GM: float) -> numpy.ndarray[numpy.float64[6, 1]]: ...
@overload
def classical2quasi_nonsingular(coe: numpy.ndarray[numpy.float64[6, 1]], GM: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def classical2quasi_nonsingular(coe: numpy.ndarray[numpy.float64[m, 6]], GM: float) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def classical2quasi_nonsingular(coe: numpy.ndarray[numpy.float64[m, 6]], GM: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def compute_occultation(epoch: float, r1: numpy.ndarray[numpy.float64[3, 1]], r2: numpy.ndarray[numpy.float64[3, 1]], cs1: Frame, cs2: Frame, bodies: list[NaifId], atm_h: numpy.ndarray[numpy.float64[m, 1]]) -> dict[str, bool]: ...
@overload
def compute_occultation(epoch: float, r1: numpy.ndarray[numpy.float64[m, 3]], r2: numpy.ndarray[numpy.float64[m, 3]], cs1: Frame, cs2: Frame, bodies: list[NaifId], atm_h: numpy.ndarray[numpy.float64[m, 1]]) -> list[dict[str, bool]]: ...
@overload
def compute_occultation(epoch: numpy.ndarray[numpy.float64[m, 1]], r1: numpy.ndarray[numpy.float64[m, 3]], r2: numpy.ndarray[numpy.float64[m, 3]], cs1: Frame, cs2: Frame, bodies: list[NaifId], atm_h: numpy.ndarray[numpy.float64[m, 1]]) -> list[dict[str, bool]]: ...
@overload
def convert_frame(t_tai: float, rv_in: numpy.ndarray[numpy.float64[6, 1]], frame_in: Frame, frame_out: Frame, rotate_only: bool = ...) -> numpy.ndarray[numpy.float64[6, 1]]: ...
@overload
def convert_frame(t_tai: float, r_in: numpy.ndarray[numpy.float64[3, 1]], frame_in: Frame, frame_out: Frame, rotate_only: bool = ...) -> numpy.ndarray[numpy.float64[3, 1]]: ...
@overload
def convert_frame(t_tai: numpy.ndarray[numpy.float64[m, 1]], rv_in: numpy.ndarray[numpy.float64[6, 1]], frame_in: Frame, frame_out: Frame, rotate_only: bool = ...) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def convert_frame(t_tai: numpy.ndarray[numpy.float64[m, 1]], r_in: numpy.ndarray[numpy.float64[3, 1]], frame_in: Frame, frame_out: Frame, rotate_only: bool = ...) -> numpy.ndarray[numpy.float64[m, 3]]: ...
@overload
def convert_frame(t_tai: float, rv_in: numpy.ndarray[numpy.float64[m, 6]], frame_in: Frame, frame_out: Frame, rotate_only: bool = ...) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def convert_frame(t_tai: float, r_in: numpy.ndarray[numpy.float64[m, 3]], frame_in: Frame, frame_out: Frame, rotate_only: bool = ...) -> numpy.ndarray[numpy.float64[m, 3]]: ...
@overload
def convert_frame(t_tai: numpy.ndarray[numpy.float64[m, 1]], rv_in: numpy.ndarray[numpy.float64[m, 6]], frame_in: Frame, frame_out: Frame, rotate_only: bool = ...) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def convert_frame(t_tai: numpy.ndarray[numpy.float64[m, 1]], r_in: numpy.ndarray[numpy.float64[m, 3]], frame_in: Frame, frame_out: Frame, rotate_only: bool = ...) -> numpy.ndarray[numpy.float64[m, 3]]: ...
@overload
def convert_orbit_state(arg0: numpy.ndarray[numpy.float64[6, 1]], arg1: OrbitStateRepres, arg2: OrbitStateRepres, arg3: float) -> numpy.ndarray[numpy.float64[6, 1]]: ...
@overload
def convert_orbit_state(arg0: numpy.ndarray[numpy.float64[6, 1]], arg1, arg2: OrbitStateRepres, arg3: OrbitStateRepres, arg4: OrbitStateRepres, arg5: float) -> numpy.ndarray[numpy.float64[6, 1]]: ...
@overload
def convert_time(t: float, _from: Time, to: Time) -> float: ...
@overload
def convert_time(t: numpy.ndarray[numpy.float64[m, 1]], _from: Time, to: Time) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def decibel2decimal(x: float) -> float: ...
@overload
def decibel2decimal(x: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def decibel2decimal(x: numpy.ndarray[numpy.float64[m, n]]) -> numpy.ndarray[numpy.float64[m, n]]: ...
@overload
def decimal2decibel(x: float) -> float: ...
@overload
def decimal2decibel(x: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def decimal2decibel(x: numpy.ndarray[numpy.float64[m, n]]) -> numpy.ndarray[numpy.float64[m, n]]: ...
def deg_min_sec2degrees(hms: numpy.ndarray[numpy.float64[3, 1]]) -> float: ...
def degrees2deg_min_sec(deg: float) -> numpy.ndarray[numpy.float64[3, 1]]: ...
@overload
def delaunay2classical(deloe, GM: float) -> ClassicalOE: ...
@overload
def delaunay2classical(deloe: numpy.ndarray[numpy.float64[6, 1]], GM: float) -> numpy.ndarray[numpy.float64[6, 1]]: ...
@overload
def delaunay2classical(deloe: numpy.ndarray[numpy.float64[6, 1]], GM: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def delaunay2classical(deloe: numpy.ndarray[numpy.float64[m, 6]], GM: float) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def delaunay2classical(deloe: numpy.ndarray[numpy.float64[m, 6]], GM: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def east_north_up2cart(enu: numpy.ndarray[numpy.float64[3, 1]], xyz_ref: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]: ...
@overload
def east_north_up2cart(enu: numpy.ndarray[numpy.float64[1, 3]], xyz_ref: numpy.ndarray[numpy.float64[1, 3]]) -> numpy.ndarray[numpy.float64[1, 3]]: ...
@overload
def east_north_up2cart(enu: numpy.ndarray[numpy.float64[m, 3]], xyz_ref: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[m, 3]]: ...
@overload
def east_north_up2cart(enu: numpy.ndarray[numpy.float64[3, 1]], xyz_ref: numpy.ndarray[numpy.float64[m, 3]]) -> numpy.ndarray[numpy.float64[m, 3]]: ...
@overload
def east_north_up2cart(enu: numpy.ndarray[numpy.float64[m, 3]], xyz_ref: numpy.ndarray[numpy.float64[m, 3]]) -> numpy.ndarray[numpy.float64[m, 3]]: ...
@overload
def eccentric2mean_anomaly(E: float, e: float) -> float: ...
@overload
def eccentric2mean_anomaly(E: numpy.ndarray[numpy.float64[m, 1]], e: float) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def eccentric2mean_anomaly(E: float, e: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def eccentric2mean_anomaly(E: numpy.ndarray[numpy.float64[m, 1]], e: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def eccentric2true_anomaly(E: float, e: float) -> float: ...
@overload
def eccentric2true_anomaly(E: numpy.ndarray[numpy.float64[m, 1]], e: float) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def eccentric2true_anomaly(E: float, e: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def eccentric2true_anomaly(E: numpy.ndarray[numpy.float64[m, 1]], e: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def equinoctial2classical(eqoe: EquinoctialOE, GM: float) -> ClassicalOE: ...
@overload
def equinoctial2classical(eqoe: numpy.ndarray[numpy.float64[6, 1]], GM: float) -> numpy.ndarray[numpy.float64[6, 1]]: ...
@overload
def equinoctial2classical(eqoe: numpy.ndarray[numpy.float64[6, 1]], GM: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def equinoctial2classical(eqoe: numpy.ndarray[numpy.float64[m, 6]], GM: float) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def equinoctial2classical(eqoe: numpy.ndarray[numpy.float64[m, 6]], GM: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def get_body_pos_vel(t_tai: float, center: NaifId, target: NaifId, frame: Frame) -> numpy.ndarray[numpy.float64[6, 1]]: ...
@overload
def get_body_pos_vel(t_tai: numpy.ndarray[numpy.float64[m, 1]], center: NaifId, target: NaifId, frame: Frame) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def get_body_pos_vel(t_tai: float, target: NaifId, frame: Frame) -> numpy.ndarray[numpy.float64[6, 1]]: ...
@overload
def get_body_pos_vel(t_tai: numpy.ndarray[numpy.float64[m, 1]], target: NaifId, frame: Frame) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def get_orbital_period(a: float, GM: float) -> float: ...
@overload
def get_orbital_period(a: numpy.ndarray[numpy.float64[m, 1]], GM: float) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def get_orbital_period(a: float, GM: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def get_orbital_period(a: numpy.ndarray[numpy.float64[m, 1]], GM: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def gps2tai(t_gps: float) -> float: ...
@overload
def gps2tai(t_gps: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
def gregorian2mjd(year: int, month: int, day: int, hour: int = ..., min: int = ..., sec: float = ...) -> float: ...
def gregorian2time(year: int, month: int, day: int, hour: int = ..., min: int = ..., sec: float = ...) -> float: ...
@overload
def inertial2synodic(rv_c: numpy.ndarray[numpy.float64[6, 1]], rv_d: numpy.ndarray[numpy.float64[6, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]: ...
@overload
def inertial2synodic(rv_c: numpy.ndarray[numpy.float64[1, 6]], rv_d: numpy.ndarray[numpy.float64[1, 6]]) -> numpy.ndarray[numpy.float64[1, 6]]: ...
@overload
def inertial2synodic(rv_c: numpy.ndarray[numpy.float64[m, 6]], rv_d: numpy.ndarray[numpy.float64[6, 1]]) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def inertial2synodic(rv_c: numpy.ndarray[numpy.float64[6, 1]], rv_d: numpy.ndarray[numpy.float64[m, 6]]) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def inertial2synodic(rv_c: numpy.ndarray[numpy.float64[m, 6]], rv_d: numpy.ndarray[numpy.float64[m, 6]]) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def jd2time(jd: float) -> float: ...
@overload
def jd2time(jd: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def lat_lon_alt2cart(r_geo: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]: ...
@overload
def lat_lon_alt2cart(r_geo: numpy.ndarray[numpy.float64[m, 3]]) -> numpy.ndarray[numpy.float64[m, 3]]: ...
@overload
def lat_lon_alt2cart(r_geo: numpy.ndarray[numpy.float64[3, 1]], R_body: float) -> numpy.ndarray[numpy.float64[3, 1]]: ...
@overload
def lat_lon_alt2cart(r_geo: numpy.ndarray[numpy.float64[3, 1]], R_body: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 3]]: ...
@overload
def lat_lon_alt2cart(r_geo: numpy.ndarray[numpy.float64[m, 3]], R_body: float) -> numpy.ndarray[numpy.float64[m, 3]]: ...
@overload
def lat_lon_alt2cart(r_geo: numpy.ndarray[numpy.float64[m, 3]], R_body: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 3]]: ...
@overload
def mean2eccentric_anomaly(M: float, e: float) -> float: ...
@overload
def mean2eccentric_anomaly(M: numpy.ndarray[numpy.float64[m, 1]], e: float) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def mean2eccentric_anomaly(M: float, e: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def mean2eccentric_anomaly(M: numpy.ndarray[numpy.float64[m, 1]], e: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def mean2true_anomaly(M: float, e: float) -> float: ...
@overload
def mean2true_anomaly(M: numpy.ndarray[numpy.float64[m, 1]], e: float) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def mean2true_anomaly(M: float, e: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def mean2true_anomaly(M: numpy.ndarray[numpy.float64[m, 1]], e: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
def mjd2gregorian(mjd: float) -> tuple[int, int, int, int, int, float]: ...
def mjd2gregorian_string(mjd: float, precision: int = ...) -> str: ...
@overload
def mjd2time(mjd: float) -> float: ...
@overload
def mjd2time(mjd: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def quasi_nonsingular2classical(arg0: QuasiNonsingOE, arg1: float) -> ClassicalOE: ...
@overload
def quasi_nonsingular2classical(qnsoe: numpy.ndarray[numpy.float64[6, 1]], GM: float) -> numpy.ndarray[numpy.float64[6, 1]]: ...
@overload
def quasi_nonsingular2classical(qnsoe: numpy.ndarray[numpy.float64[6, 1]], GM: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def quasi_nonsingular2classical(qnsoe: numpy.ndarray[numpy.float64[m, 6]], GM: float) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def quasi_nonsingular2classical(qnsoe: numpy.ndarray[numpy.float64[m, 6]], GM: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 6]]: ...
def quat2rot(q: numpy.ndarray[numpy.float64[4, 1]]) -> numpy.ndarray[numpy.float64[3, 3]]: ...
@overload
def relative_quasi_nonsingular2classical(coe: ClassicalOE, rel_qnsoe: QuasiNonsingROE) -> ClassicalOE: ...
@overload
def relative_quasi_nonsingular2classical(coe: numpy.ndarray[numpy.float64[6, 1]], rel_qnsoe: numpy.ndarray[numpy.float64[6, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]: ...
@overload
def relative_quasi_nonsingular2classical(coe: numpy.ndarray[numpy.float64[1, 6]], rel_qnsoe: numpy.ndarray[numpy.float64[1, 6]]) -> numpy.ndarray[numpy.float64[1, 6]]: ...
@overload
def relative_quasi_nonsingular2classical(coe: numpy.ndarray[numpy.float64[m, 6]], rel_qnsoe: numpy.ndarray[numpy.float64[6, 1]]) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def relative_quasi_nonsingular2classical(coe: numpy.ndarray[numpy.float64[6, 1]], rel_qnsoe: numpy.ndarray[numpy.float64[m, 6]]) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def relative_quasi_nonsingular2classical(coe: numpy.ndarray[numpy.float64[m, 6]], rel_qnsoe: numpy.ndarray[numpy.float64[m, 6]]) -> numpy.ndarray[numpy.float64[m, 6]]: ...
def rot2quat(R: numpy.ndarray[numpy.float64[3, 3]]) -> numpy.ndarray[numpy.float64[4, 1]]: ...
def rot_x(angle: float) -> numpy.ndarray[numpy.float64[3, 3]]: ...
def rot_y(angle: float) -> numpy.ndarray[numpy.float64[3, 3]]: ...
def rot_z(angle: float) -> numpy.ndarray[numpy.float64[3, 3]]: ...
def skew(x: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 3]]: ...
@overload
def synodic2intertial(rv_c: numpy.ndarray[numpy.float64[6, 1]], rv_d: numpy.ndarray[numpy.float64[6, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]: ...
@overload
def synodic2intertial(rv_c: numpy.ndarray[numpy.float64[1, 6]], rv_d: numpy.ndarray[numpy.float64[1, 6]]) -> numpy.ndarray[numpy.float64[1, 6]]: ...
@overload
def synodic2intertial(rv_c: numpy.ndarray[numpy.float64[m, 6]], rv_d: numpy.ndarray[numpy.float64[6, 1]]) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def synodic2intertial(rv_c: numpy.ndarray[numpy.float64[6, 1]], rv_d: numpy.ndarray[numpy.float64[m, 6]]) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def synodic2intertial(rv_c: numpy.ndarray[numpy.float64[m, 6]], rv_d: numpy.ndarray[numpy.float64[m, 6]]) -> numpy.ndarray[numpy.float64[m, 6]]: ...
@overload
def tai2gps(t_tai: float) -> float: ...
@overload
def tai2gps(t_tai: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def tai2tt(t_tai: float) -> float: ...
@overload
def tai2tt(t_tai: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def tai2utc(t_tai: float) -> float: ...
@overload
def tai2utc(t_tai: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def tcb2tdb(t_tcb: float) -> float: ...
@overload
def tcb2tdb(t_tcb: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def tcg2tt(t_tcg: float) -> float: ...
@overload
def tcg2tt(t_tcg: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def tdb2tt(t_tdb: float) -> float: ...
@overload
def tdb2tt(t_tdb: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
def time2gregorian_string(t: float, precision: int = ...) -> str: ...
@overload
def time2jd(t: float) -> float: ...
@overload
def time2jd(t: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def time2mjd(t: float) -> float: ...
@overload
def time2mjd(t: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def true2eccentric_anomaly(nu: float, e: float) -> float: ...
@overload
def true2eccentric_anomaly(nu: numpy.ndarray[numpy.float64[m, 1]], e: float) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def true2eccentric_anomaly(nu: float, e: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def true2eccentric_anomaly(nu: numpy.ndarray[numpy.float64[m, 1]], e: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def true2mean_anomaly(f: float, e: float) -> float: ...
@overload
def true2mean_anomaly(f: numpy.ndarray[numpy.float64[m, 1]], e: float) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def true2mean_anomaly(f: float, e: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def true2mean_anomaly(f: numpy.ndarray[numpy.float64[m, 1]], e: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def tt2tai(t_tt: float) -> float: ...
@overload
def tt2tai(t_tt: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def tt2tcb(t_tdb: float) -> float: ...
@overload
def tt2tcb(t_tdb: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def tt2tcg(t_tt: float) -> float: ...
@overload
def tt2tcg(t_tt: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def tt2tdb(t_tt: float) -> float: ...
@overload
def tt2tdb(t_tt: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def ut12utc(t_ut1: float) -> float: ...
@overload
def ut12utc(t_ut1: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def utc2tai(t_utc: float) -> float: ...
@overload
def utc2tai(t_utc: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def utc2ut1(t_utc: float) -> float: ...
@overload
def utc2ut1(t_utc: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def wrap2pi(arg0: float) -> float: ...
@overload
def wrap2pi(arg0: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def wrap2two_pi(arg0: float) -> float: ...
@overload
def wrap2two_pi(arg0: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]: ...
